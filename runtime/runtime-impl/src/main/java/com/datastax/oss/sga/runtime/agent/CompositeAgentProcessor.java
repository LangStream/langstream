package com.datastax.oss.sga.runtime.agent;

import com.datastax.oss.sga.api.runner.code.AgentCode;
import com.datastax.oss.sga.api.runner.code.AgentCodeProvider;
import com.datastax.oss.sga.api.runner.code.AgentContext;
import com.datastax.oss.sga.api.runner.code.AgentFunction;
import com.datastax.oss.sga.api.runner.code.Record;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This is a special processor that executes a pipeline of Agents in memory.
 */
public class CompositeAgentProcessor implements AgentFunction {

    private final List<AgentFunction> agents = new ArrayList<>();
    @Override
    public void init(Map<String, Object> configuration) throws Exception {
        List<Map<String, Object>> agentsDefinitions = null;
        if (configuration.containsKey("agents")) {
            agentsDefinitions = (List<Map<String, Object>>) configuration.get("agents");
        }
        if (agentsDefinitions == null || agentsDefinitions.isEmpty()) {
            throw new IllegalArgumentException("No agents defined");
        }
        for (Map<String, Object> agentDefinition : agentsDefinitions) {
            String agentType = (String) agentDefinition.get("agentType");
            Map<String, Object> agentConfiguration = (Map<String, Object>) agentDefinition.get("configuration");
            AgentFunction agent = (AgentFunction) AgentRunner.initAgent(agentType, agentConfiguration);
            agents.add(agent);
        }
    }

    @Override
    public void setContext(AgentContext context) throws Exception {
        // we are not setting the Context on wrapped Agents
        // the context would allow them to access the Consumers and the Producers
        // and this functionality is not supported in this processor
    }

    @Override
    public void start() throws Exception {
        for (AgentFunction agent : agents) {
            agent.start();
        }
    }

    @Override
    public void close() throws Exception {
        for (AgentFunction agent : agents) {
            agent.close();
        }
    }

    @Override
    public List<SourceRecordAndResult> process(List<Record> records) throws Exception {

        int current = 0;
        AgentFunction currentAgent = agents.get(current++);
        List<SourceRecordAndResult> currentResults = currentAgent.process(records);

        // we must preserve the original mapping to the Source Record
        // each SourceRecord generates some SinkRecords
        while (current < agents.size()) {
            List<SourceRecordAndResult>  nextStageResults = new ArrayList<>();

            currentAgent = agents.get(current++);
            for (SourceRecordAndResult entry : currentResults) {
                // we pass to the next agent only records generated by the same SourceRecord
                // this reduces a lot the complexity of the code, but it defeats micro-batching
                // this algorithm can be improved in the future
                Record sourceRecord = entry.getSourceRecord();
                List<Record> sinkRecords = entry.getResultRecords();
                List<SourceRecordAndResult> processed = currentAgent.process(sinkRecords);
                nextStageResults.add(new SourceRecordAndResult(sourceRecord,
                        processed
                                .stream()
                                .map(SourceRecordAndResult::getResultRecords)
                                .flatMap(List::stream).toList()));

            }
            currentResults = nextStageResults;
        }

        return currentResults;
    }

}
